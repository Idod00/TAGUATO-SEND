worker_processes auto;
error_log /usr/local/openresty/nginx/logs/error.log warn;

# Expose env vars to Lua (nginx strips env vars by default)
env AUTHENTICATION_API_KEY;
env PG_HOST;
env PG_PORT;
env PG_DATABASE;
env PG_USER;
env PG_PASSWORD;
env REDIS_HOST;
env REDIS_PORT;
env BACKUP_INTERVAL;

events {
    worker_connections 1024;
}

http {
    include mime.types;
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";

    # Docker internal DNS resolver
    resolver 127.0.0.11 ipv6=off;

    # Structured JSON access log
    log_format json_combined escape=json
        '{"ts":"$time_iso8601",'
        '"ip":"$remote_addr",'
        '"method":"$request_method",'
        '"uri":"$request_uri",'
        '"status":$status,'
        '"body_bytes":$body_bytes_sent,'
        '"request_time":$request_time,'
        '"ua":"$http_user_agent"}';
    access_log /usr/local/openresty/nginx/logs/access.log json_combined;

    # Rate limit for status API: 10 req/s per IP, burst 20
    limit_req_zone $binary_remote_addr zone=status_api:1m rate=10r/s;

    # Rate limit for message sending: 5 req/s per IP, burst 10
    limit_req_zone $binary_remote_addr zone=msg_send:2m rate=5r/s;

    upstream evolution_api {
        server taguato-api:8080;
        keepalive 16;
    }

    # Workers: migration, uptime, reconnect, scheduled, backup (all on worker 0)
    init_worker_by_lua_block {
        if ngx.worker.id() == 0 then
            -- Run migrations first (5 second delay for DB readiness)
            ngx.timer.at(5, function(premature)
                if premature then return end
                local ok, err = pcall(function()
                    local migrate = require "migrate_worker"
                    migrate.run()
                end)
                if not ok then
                    ngx.log(ngx.ERR, "migration worker failed: ", err)
                end
            end)

            local function run_uptime_check(premature)
                if premature then return end
                local ok, err = pcall(function()
                    local uptime_worker = require "uptime_worker"
                    uptime_worker.check()
                end)
                if not ok then
                    ngx.log(ngx.ERR, "uptime check failed: ", err)
                end
            end
            local ok, err = ngx.timer.every(300, run_uptime_check)
            if not ok then
                ngx.log(ngx.ERR, "failed to create uptime timer: ", err)
            end
            -- Run first check after 10 seconds
            ngx.timer.at(10, run_uptime_check)

            -- Auto-reconnect worker (every 3 minutes)
            local function run_reconnect(premature)
                if premature then return end
                local ok, err = pcall(function()
                    local reconnect = require "reconnect_worker"
                    reconnect.check()
                end)
                if not ok then
                    ngx.log(ngx.ERR, "reconnect worker failed: ", err)
                end
            end
            local ok2, err2 = ngx.timer.every(180, run_reconnect)
            if not ok2 then
                ngx.log(ngx.ERR, "failed to create reconnect timer: ", err2)
            end
            -- First reconnect check after 30 seconds
            ngx.timer.at(30, run_reconnect)

            -- Scheduled messages worker (every 60 seconds)
            local function run_scheduled(premature)
                if premature then return end
                local ok, err = pcall(function()
                    local sched = require "scheduled_worker"
                    sched.check()
                end)
                if not ok then
                    ngx.log(ngx.ERR, "scheduled worker failed: ", err)
                end
            end
            local ok3, err3 = ngx.timer.every(60, run_scheduled)
            if not ok3 then
                ngx.log(ngx.ERR, "failed to create scheduled timer: ", err3)
            end
            ngx.timer.at(45, run_scheduled)

            -- Auto backup worker
            local function run_backup(premature)
                if premature then return end
                local ok, err = pcall(function()
                    local backup = require "backup_worker"
                    backup.run()
                end)
                if not ok then
                    ngx.log(ngx.ERR, "backup worker failed: ", err)
                end
            end
            local backup_interval = tonumber(os.getenv("BACKUP_INTERVAL")) or 86400
            local ok4, err4 = ngx.timer.every(backup_interval, run_backup)
            if not ok4 then
                ngx.log(ngx.ERR, "failed to create backup timer: ", err4)
            end
            -- First backup after 60 seconds
            ngx.timer.at(60, run_backup)
        end
    }

    server {
        listen 80;
        server_name _;

        # Increase body size for media uploads
        client_max_body_size 50m;

        # CORS headers for all responses
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "apikey, Content-Type, Authorization" always;
        add_header Access-Control-Max-Age 86400 always;

        # Handle preflight OPTIONS requests
        if ($request_method = OPTIONS) {
            return 204;
        }

        # ---- Health check (no auth) ----
        location = /health {
            content_by_lua_block {
                local ok, err = pcall(function()
                    local db = require "init"
                    local res = db.query("SELECT 1 as check")
                    if not res then error("db query failed") end
                end)
                if ok then
                    ngx.say('{"status":"ok","gateway":"taguato","db":"connected"}')
                else
                    ngx.status = 503
                    ngx.say('{"status":"degraded","gateway":"taguato","db":"disconnected"}')
                end
            }
        }

        # ---- Admin endpoints (requires admin role) ----
        location /admin/ {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
        }

        # ---- Manager (admin only, proxied to Evolution API) ----
        location /manager/ {
            access_by_lua_block {
                local token = ngx.req.get_headers()["apikey"]
                if not token or token == "" then
                    -- Manager UI serves static assets; allow through with API key
                    ngx.req.set_header("apikey", os.getenv("AUTHENTICATION_API_KEY"))
                    return
                end

                local db = require "init"
                local json = require "json"

                local res = db.query(
                    "SELECT id, role, is_active FROM taguato.users WHERE api_token = $1 LIMIT 1",
                    token
                )

                if not res or #res == 0 then
                    json.respond(401, { error = "Invalid API token" })
                    return
                end

                if not res[1].is_active then
                    json.respond(403, { error = "Account is disabled" })
                    return
                end

                if res[1].role ~= "admin" then
                    json.respond(403, { error = "Admin access required for Manager" })
                    return
                end

                ngx.req.set_header("apikey", os.getenv("AUTHENTICATION_API_KEY"))
            }

            proxy_pass http://evolution_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # ---- Swagger docs (admin only) ----
        location /docs {
            access_by_lua_block {
                local token = ngx.req.get_headers()["apikey"]
                if not token or token == "" then
                    ngx.req.set_header("apikey", os.getenv("AUTHENTICATION_API_KEY"))
                    return
                end

                local db = require "init"
                local json = require "json"

                local res = db.query(
                    "SELECT role, is_active FROM taguato.users WHERE api_token = $1 LIMIT 1",
                    token
                )

                if res and #res > 0 and res[1].is_active and res[1].role == "admin" then
                    ngx.req.set_header("apikey", os.getenv("AUTHENTICATION_API_KEY"))
                    return
                end

                json.respond(403, { error = "Admin access required" })
            }

            proxy_pass http://evolution_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_http_version 1.1;
        }

        # ---- Favicon (no auth) ----
        location = /favicon.ico {
            alias /usr/local/openresty/nginx/panel/favicon.ico;
            access_log off;
        }

        # ---- Panel service worker ----
        location = /panel/sw.js {
            alias /usr/local/openresty/nginx/panel/sw.js;
            add_header Service-Worker-Allowed /;
            add_header Cache-Control "no-cache";
        }

        # ---- Panel static files ----
        location /panel/ {
            alias /usr/local/openresty/nginx/panel/;
            index index.html;
        }

        # ---- Panel auth endpoints ----
        location /api/auth/ {
            content_by_lua_file /usr/local/openresty/nginx/lua/panel_auth.lua;
        }

        # ---- User dashboard (all users) ----
        location = /api/user/dashboard {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/user_dashboard.lua;
        }

        # ---- Message history CSV export ----
        location = /api/messages/export {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/export.lua;
        }

        # ---- Message logs ----
        location /api/messages/log {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/message_log.lua;
        }

        # ---- User sessions ----
        location /api/sessions {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/sessions.lua;
        }

        # ---- Admin sessions management ----
        location /admin/sessions {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/sessions.lua;
        }

        # ---- Message templates (user-scoped) ----
        location /api/templates {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/templates.lua;
        }

        # ---- Contact lists (user-scoped) ----
        location /api/contacts {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/contacts.lua;
        }

        # ---- User webhooks (user-scoped) ----
        location /api/webhooks {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/webhooks.lua;
        }

        # ---- Scheduled messages (user-scoped) ----
        location /api/scheduled {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/scheduled.lua;
        }

        # ---- Redirect root to panel for browsers ----
        location = / {
            content_by_lua_block {
                return ngx.redirect("/panel/", 302)
            }
        }

        # ---- Internal health check for Evolution API (used by status_api) ----
        location = /_internal/api_health {
            internal;
            proxy_pass http://evolution_api/;
            proxy_connect_timeout 3s;
            proxy_read_timeout 3s;
        }

        # ---- Public status page (no auth) ----
        location /status/ {
            alias /usr/local/openresty/nginx/panel/status/;
            index index.html;
        }

        location = /status {
            return 301 /status/;
        }

        # ---- Public status API (no auth, rate limited) ----
        location = /api/status {
            limit_req zone=status_api burst=20 nodelay;
            content_by_lua_file /usr/local/openresty/nginx/lua/status_api.lua;
        }

        # ---- Admin dashboard ----
        location = /admin/dashboard {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/dashboard_api.lua;
        }

        # ---- Internal fetchInstances (used by dashboard) ----
        location = /_internal/fetch_instances {
            internal;
            set_by_lua_block $internal_apikey { return os.getenv("AUTHENTICATION_API_KEY") }
            proxy_pass http://evolution_api/instance/fetchInstances;
            proxy_set_header apikey $internal_apikey;
            proxy_connect_timeout 5s;
            proxy_read_timeout 5s;
        }

        # ---- Admin incidents management ----
        location /admin/incidents {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/incidents_admin.lua;
        }

        # ---- Admin audit log ----
        location = /admin/audit {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_block {
                local audit = require "audit"
                audit.handle()
            }
        }

        # ---- Admin backup management ----
        location /admin/backup {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/backup_admin.lua;
        }

        # ---- Admin maintenance management ----
        location /admin/maintenance {
            access_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            content_by_lua_file /usr/local/openresty/nginx/lua/maintenance_admin.lua;
        }

        # ---- Message sending (rate limited) ----
        location /message/ {
            limit_req zone=msg_send burst=10 nodelay;

            access_by_lua_file /usr/local/openresty/nginx/lua/access.lua;

            proxy_pass http://evolution_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
        }

        # ---- All API requests (auth + instance filter + proxy) ----
        location / {
            access_by_lua_file /usr/local/openresty/nginx/lua/access.lua;

            proxy_pass http://evolution_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Response filter for fetchInstances
            body_filter_by_lua_file /usr/local/openresty/nginx/lua/response_filter.lua;
        }
    }
}
